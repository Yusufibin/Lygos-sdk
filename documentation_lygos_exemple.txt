 
exemple de fonctionnement de lygos
# --- START: Lygos Configuration ---
LYGOS_API_KEY = os.getenv('LYGOS_API_KEY', "lygosapp-552bc86a-1e27-425e-b18e-bc8decc2e60a") # Remplacez par votre clé API Lygos ou mettez-la dans les variables d'environnement
LYGOS_CREATE_GATEWAY_URL = "https://api.lygosapp.com/v1/gateway"
LYGOS_GET_PAYIN_STATUS_URL = "https://api.lygosapp.com/v1/gateway/payin/" # Note: {order_id} sera ajouté à la fin
LYGOS_SHOP_NAME = "Mariam AI"


#-------------- lygos ---------
def create_lygos_payment_link(
    amount: int,
    shop_name: str,
    message: str,
    order_id: str,
    meta_data: Optional[Dict] = None,
    success_url: Optional[str] = None,
    failure_url: Optional[str] = None
) -> Optional[str]:
    """
    Creates a payment gateway link using Lygos API.
    """
    payload = {
        "amount": int(amount),
        "shop_name": shop_name,
        "message": message,
        "order_id": order_id,
        "success_url": success_url or url_for('success', _external=True, payment_provider='lygos', order_id=order_id),
        "failure_url": failure_url or url_for('error', _external=True, payment_provider='lygos', order_id=order_id)
    }

    headers = {
        "api-key": LYGOS_API_KEY,
        "Content-Type": "application/json"
    }

    try:
        current_app.logger.info(f"--- Requête Lygos Create Gateway ---")
        current_app.logger.info(f"URL: {LYGOS_CREATE_GATEWAY_URL}")
        current_app.logger.info(f"Headers: {{'api-key': 'LYGOS_API_KEY_HIDDEN', 'Content-Type': 'application/json'}}")
        current_app.logger.info(f"Payload: {json.dumps(payload, indent=2)}")

        response = requests.post(
            LYGOS_CREATE_GATEWAY_URL,
            headers=headers,
            json=payload,
            timeout=30
        )
        response.raise_for_status()
        response_data = response.json()

        current_app.logger.info(f"--- Réponse Lygos Create Gateway ---")
        current_app.logger.info(f"Status Code: {response.status_code}")
        current_app.logger.info(f"Body: {json.dumps(response_data, indent=2)}")

        payment_link = response_data.get("link")

        if payment_link:
            current_app.logger.info(f"Lien de paiement Lygos obtenu avec succès: {payment_link}")
            return payment_link
        else:
            error_message = response_data.get("message", "L'API Lygos n'a pas retourné de lien de paiement.")
            current_app.logger.error(f"Erreur API Lygos (lien manquant): {error_message}")
            flash(f"Erreur lors de la création du lien de paiement Lygos : {error_message}", "danger")
            return None

    except requests.exceptions.HTTPError as http_err:
        current_app.logger.error(f"Erreur HTTP Lygos: {http_err}")
        try:
            error_body = http_err.response.json()
            current_app.logger.error(f"Corps de la réponse d'erreur Lygos: {json.dumps(error_body, indent=2)}")
            api_message = error_body.get("message", "Erreur inconnue de l'API Lygos.")
            flash(f"Erreur du service de paiement Lygos : {api_message}", "danger")
        except json.JSONDecodeError:
            current_app.logger.error(f"Réponse d'erreur Lygos (non-JSON): {http_err.response.text}")
            flash("Erreur de communication avec le service de paiement Lygos.", "danger")
        return None
    except requests.exceptions.RequestException as req_err:
        current_app.logger.error(f"Erreur de requête Lygos: {req_err}")
        flash("Impossible de contacter le service de paiement Lygos. Vérifiez votre connexion ou réessayez.", "danger")
        return None
    except Exception as e:
        current_app.logger.error(f"Erreur inattendue (Lygos): {e}")
        flash("Une erreur interne est survenue (Lygos).", "danger")
        return None


@app.route('/acheter_abonnement_lygos', methods=['GET'])
@login_required
def acheter_abonnement_lygos():
    """Handles the subscription purchase process using Lygos."""
    user_id = session.get('user_id')
    plan = request.args.get('plan')

    if not plan:
        flash("Veuillez sélectionner un plan.", "warning")
        return redirect(url_for('profile'))

    conn = create_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("SELECT nom FROM utilisateurs WHERE id = %s", (user_id,))
    user_data = cursor.fetchone()
    cursor.close()
    conn.close()

    if not user_data:
        flash("Utilisateur non trouvé.", "error")
        return redirect(url_for('profile'))

    buyer_name = user_data.get('nom', 'Utilisateur Mariam')

    # Générer un order_id unique pour Lygos
    timestamp_short = str(int(time.time()))[-6:]
    plan_initial = plan[0].upper()
    order_id = f"LYGOS{plan_initial}{user_id}{timestamp_short}"

    # meta_data à stocker et récupérer plus tard
    meta_data_for_webhook = {"user_id": user_id, "plan": plan, "username": buyer_name, "payment_provider": "lygos"}

    if plan == 'basique':
        product_name = "Mariam AI - Mode Basique"
        price = 2425 
        message_lygos = f"Abonnement Mariam AI Basique pour {buyer_name}"
    elif plan == 'avance':
        product_name = "Mariam AI - Mode Avancé"
        price = 4850  # Pour test
        message_lygos = f"Abonnement Mariam AI Avancé pour {buyer_name}"
    else:
        flash("Plan d'abonnement invalide.", "warning")
        return redirect(url_for('profile'))

    # Appel à la fonction Lygos
    lien_paiement = create_lygos_payment_link(
        amount=price,
        shop_name=LYGOS_SHOP_NAME,
        message=message_lygos,
        order_id=order_id,
        meta_data=meta_data_for_webhook
    )

    if lien_paiement:
        current_app.logger.info(f"Redirection vers le lien de paiement Lygos: {lien_paiement}")
        return redirect(lien_paiement)
    else:
        return redirect(url_for('profile'))


@app.route('/success')
def success():
    """
    Page de succès après paiement.
    Traite l'activation de l'abonnement pour Lygos quand le paiement est réussi.
    """
    payment_provider = request.args.get('payment_provider')
    order_id = request.args.get('order_id')
    
    current_app.logger.info(f"--- Page de succès atteinte ---")
    current_app.logger.info(f"Payment provider: {payment_provider}, Order ID: {order_id}")
    
    # Traitement spécifique pour Lygos
    if payment_provider == 'lygos' and order_id:
        try:
            # Extraire les informations directement de l'order_id avec regex
            # Format: LYGOS{plan_initial}{user_id}{timestamp}
            # Exemple: LYGOSA100211920 = LYGOS + A(vancé) + 100 + 211920
            import re
            match = re.match(r'LYGOS([AB])(\d+)(\d{6})', order_id)
            
            if not match:
                current_app.logger.error(f"Succès Lygos: Format order_id invalide: {order_id}")
                flash("Erreur dans l'identifiant de commande.", "error")
                return redirect(url_for('profile'))
            
            plan_initial, user_id_str, timestamp = match.groups()
            user_id = int(user_id_str)
            
            # Déterminer le plan à partir de l'initiale
            if plan_initial == 'A':
                plan = 'avance'
                new_status_db = 'Abonne-pro'
            elif plan_initial == 'B':
                plan = 'basique'
                new_status_db = 'Abonnee'
            else:
                current_app.logger.error(f"Succès Lygos: Plan initial invalide '{plan_initial}' dans order_id {order_id}")
                flash("Erreur: Plan d'abonnement non reconnu.", "error")
                return redirect(url_for('profile'))
            
            # Récupérer le nom d'utilisateur depuis la base
            conn = create_connection()
            cursor = conn.cursor(cursor_factory=RealDictCursor)
            cursor.execute("SELECT nom FROM utilisateurs WHERE id = %s", (user_id,))
            user_data = cursor.fetchone()
            
            if not user_data:
                current_app.logger.error(f"Succès Lygos: Utilisateur {user_id} introuvable pour order_id {order_id}")
                flash("Erreur: Utilisateur non trouvé.", "error")
                cursor.close()
                conn.close()
                return redirect(url_for('profile'))
            
            username = user_data.get('nom', 'N/A')
            
            # Activer l'abonnement
            current_app.logger.info(f"Activation abonnement Lygos pour user {user_id}, plan {plan}, order_id {order_id}")
            
            from datetime import datetime, timedelta
            date_abonnement = datetime.now().date()
            date_expiration = date_abonnement + timedelta(days=30)
            
            cursor.execute(
                """
                UPDATE utilisateurs
                SET abonnement_statut = %s,
                    date_expiration_abonnement = %s,
                    date_abonnement = %s
                WHERE id = %s
                """,
                (new_status_db, date_expiration, date_abonnement, user_id)
            )
            conn.commit()
            
            current_app.logger.info(f"SUCCÈS: Abonnement Lygos '{new_status_db}' activé pour user {user_id} (Order: {order_id})")
            
            # Notification admin
            admin_message = f"✅ Paiement Lygos Réussi (Order: {order_id}). Abonnement '{new_status_db}' activé pour user {user_id} ({username}), Plan: {plan}."
            try:
                params = {"chat_id": CHAT_ID, "text": admin_message}
                requests.get(TELEGRAM_API_URL, params=params, timeout=10)
            except Exception as telegram_err:
                current_app.logger.error(f"Erreur envoi notification Telegram: {telegram_err}")
            
            # Mettre à jour la session si c'est l'utilisateur connecté
            if session.get('user_id') == user_id:
                session['abonnement_statut'] = new_status_db
                session['date_expiration_abonnement'] = date_expiration.strftime('%Y-%m-%d')
            
            flash("Votre abonnement a été activé avec succès !", "success")
            return redirect(url_for('profile'))
            
        except psycopg2.Error as db_err:
            current_app.logger.error(f"Erreur BDD lors de l'activation Lygos (order_id {order_id}): {db_err}")
            if 'conn' in locals() and conn:
                conn.rollback()
            admin_message = f"🚨 ERREUR BDD Lygos (Order: {order_id}, User: {user_id}). Erreur: {db_err}"
            try:
                params = {"chat_id": CHAT_ID, "text": admin_message}
                requests.get(TELEGRAM_API_URL, params=params, timeout=10)
            except Exception:
                pass
            flash("Erreur lors de l'activation de l'abonnement. Contactez le support.", "error")
            return redirect(url_for('profile'))
            
        except Exception as e:
            current_app.logger.error(f"Erreur inattendue lors de l'activation Lygos (order_id {order_id}): {e}")
            if 'conn' in locals() and conn:
                conn.rollback()
            admin_message = f"🚨 ERREUR Inattendue Lygos (Order: {order_id}). Erreur: {e}"
            try:
                params = {"chat_id": CHAT_ID, "text": admin_message}
                requests.get(TELEGRAM_API_URL, params=params, timeout=10)
            except Exception:
                pass
            flash("Erreur inattendue. Contactez le support.", "error")
            return redirect(url_for('profile'))
            
        finally:
            if 'cursor' in locals() and cursor:
                cursor.close()
            if 'conn' in locals() and conn:
                conn.close()
    
    # Pour les autres providers ou si pas de traitement spécial
    return redirect(url_for('profile'))


@app.route('/error')
def error():
    """
    Page d'erreur après paiement échoué.
    """
    payment_provider = request.args.get('payment_provider')
    order_id = request.args.get('order_id')
    
    current_app.logger.info(f"--- Page d'erreur atteinte ---")
    current_app.logger.info(f"Payment provider: {payment_provider}, Order ID: {order_id}")
    
    # Notification admin pour échec
    if payment_provider == 'lygos' and order_id:
        try:
            # Extraire les informations de l'order_id pour la notification
            import re
            match = re.match(r'LYGOS([AB])(\d+)(\d{6})', order_id)
            
            if match:
                plan_initial, user_id_str, timestamp = match.groups()
                user_id = int(user_id_str)
                plan = 'avance' if plan_initial == 'A' else 'basique'
                
                # Récupérer le nom d'utilisateur
                conn = create_connection()
                cursor = conn.cursor(cursor_factory=RealDictCursor)
                cursor.execute("SELECT nom FROM utilisateurs WHERE id = %s", (user_id,))
                user_data = cursor.fetchone()
                cursor.close()
                conn.close()
                
                username = user_data.get('nom', 'N/A') if user_data else 'N/A'
                
                admin_message = f"❌ Paiement Lygos ÉCHOUÉ (Order: {order_id}). User: {user_id} ({username}), Plan: {plan}."
                
                try:
                    params = {"chat_id": CHAT_ID, "text": admin_message}
                    requests.get(TELEGRAM_API_URL, params=params, timeout=10)
                except Exception as telegram_err:
                    current_app.logger.error(f"Erreur envoi notification Telegram (échec): {telegram_err}")
            
        except Exception as e:
            current_app.logger.error(f"Erreur lors du traitement de l'échec Lygos: {e}")
    
    flash("Le paiement a échoué. Veuillez réessayer.", "error")
    return redirect(url_for('profile'))

